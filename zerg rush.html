<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Zerg Rush â€” Simple HTML Game</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{ --bg-gradient: linear-gradient(180deg,#041026 0%,#071227 60%); --panel:#0f1720; --accent:#8b5cf6; }
html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg-gradient);display:flex;align-items:center;justify-content:center;color:#e6eef8}
.wrap{width:900px;max-width:96vw;padding:18px;background:rgba(255,255,255,0.02);border-radius:12px;position:relative;z-index:2}
header{display:flex;gap:12px;align-items:center;margin-bottom:10px}
h1{font-size:18px;margin:0;color:var(--accent)}
.controls{margin-left:auto;display:flex;gap:8px;align-items:center}
button{background:var(--panel);color:#d6e6ff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
.badge{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;margin-right:8px}
canvas{display:block;width:100%;height:560px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px;cursor:crosshair}
.playWrap{ position:relative; display:block }
.overlay{position:relative;margin-top:10px;height:40px}
.msg{color:#ffdce6}
@font-face{ font-family: 'Mojangles'; src: url('Mojangles.woff2') format('woff2'); font-weight: normal; font-style: normal; font-display: swap; }
.pixel-ui{ font-family: 'Mojangles', 'Press Start 2P', monospace; -webkit-font-smoothing: none; -moz-osx-font-smoothing: grayscale; }
header, h1, .badge, .msg, button { font-family: 'Mojangles', 'Press Start 2P', monospace; }
header{ position:relative; z-index:50 }
.controls{ position:relative; z-index:60 }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Zerg Rush</h1>
      <div style="display:flex;align-items:center;">
        <div class="badge">Score: <span id="score">0</span></div>
        <div class="badge">Lives: <span id="lives">10</span></div>
        <div class="badge">Time: <span id="time">0</span>s</div>
        <div class="badge">Level: <span id="level">1</span></div>
        <div class="badge">XP: <span id="xp">0</span>/<span id="xpReq">1000</span></div>
      </div>
      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="restartBtn" disabled>Restart</button>
      </div>
    </header>

    <div class="playWrap" style="position:relative;">
      <canvas id="gameCanvas" width="880" height="560"></canvas>
    </div>

    <div class="overlay">
      <div class="msg" id="message">Click Start to begin the Zerg Rush.</div>
      <div style="margin-top:8px;height:8px;background:rgba(255,255,255,0.04);border-radius:6px;overflow:hidden;">
        <div id="xpBar" style="height:100%;width:0%;background:var(--accent);transition:width 220ms linear"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const timeEl = document.getElementById('time');
  const messageEl = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const levelEl = document.getElementById('level');
  const xpEl = document.getElementById('xp');
  const xpReqEl = document.getElementById('xpReq');
  const xpBar = document.getElementById('xpBar');

  // state
  let W = canvas.width, H = canvas.height;
  let enemies = [], particles = [];
  let lastSpawn = 0, spawnInterval = 900;
  let lastTime = 0, elapsed = 0;
  let score = 0, lives = 10;
  let running = false, gameOver = false;
  let level = 1, xp = 0, xpReq = 1000, lastSecAwarded = 0;

  function rand(a,b){ return Math.random()*(b-a)+a }
  function setMsg(t){ if(messageEl) messageEl.textContent = t }

  function saveProgress(){ try{ localStorage.setItem('zerg-level', JSON.stringify({level,xp,xpReq})); }catch(e){} }
  function loadProgress(){ try{ const s=localStorage.getItem('zerg-level'); if(s){ const o=JSON.parse(s); level=o.level||level; xp=o.xp||xp; xpReq=o.xpReq||xpReq; } }catch(e){} }

  function updateHUD(){ scoreEl.textContent = score; livesEl.textContent = lives; levelEl.textContent = level; xpEl.textContent = Math.floor(xp); xpReqEl.textContent = xpReq; if(xpBar) xpBar.style.width = Math.min(100,(xp/xpReq)*100) + '%'; saveProgress(); }

  function addXP(n){ xp += n; while(xp >= xpReq){ xp -= xpReq; level++; xpReq += 100 } updateHUD(); }

  class Particle{ 
    constructor(x,y,c){ 
      this.x=x; this.y=y; this.vx=rand(-80,80); this.vy=rand(-120,-20); 
      this.life=rand(0.3,0.9); this.age=0; this.c=c; this.s=rand(1.5,3); 
    } 
    update(dt){ 
      this.age+=dt; this.vy+=200*dt; this.x+=this.vx*dt; this.y+=this.vy*dt; 
    } 
    draw(ctx){ 
      if(this.age>this.life) return; 
      ctx.globalAlpha = 1 - this.age/this.life; 
      ctx.fillStyle = this.c; 
      ctx.beginPath(); 
      ctx.arc(this.x,this.y,this.s,0,Math.PI*2); 
      ctx.fill(); 
      ctx.globalAlpha = 1; 
    } 
  }

  class Enemy{
    constructor(x,y,r,s,type){ 
      this.x=x; this.y=y; this.r=r; this.s=s; this.type=type||'default'; 
      this.alive=true; this.angle=rand(0,Math.PI*2); 
      this.color = 'hsl('+rand(260,300)+'deg,80%,60%)'; 
    }
    update(dt){ 
      this.y += this.s*dt; 
      this.angle += 4*dt; 
      if(this.y - this.r > H){ this.alive=false; lives--; updateHUD(); } 
    }
    draw(ctx){ 
      ctx.save(); 
      ctx.translate(this.x,this.y); 
      ctx.rotate(Math.sin(this.angle)*0.2); 
      ctx.beginPath(); 
      ctx.fillStyle=this.color; 
      ctx.arc(0,0,this.r,0,Math.PI*2); 
      ctx.fill(); 
      for(let i=0;i<6;i++){ 
        let a=i*(Math.PI*2/6)+this.angle; 
        ctx.beginPath(); 
        ctx.moveTo(Math.cos(a)*(this.r*0.9),Math.sin(a)*(this.r*0.9)); 
        ctx.lineTo(Math.cos(a)*(this.r*1.7),Math.sin(a)*(this.r*1.7)); 
        ctx.strokeStyle='rgba(255,255,255,0.06)'; 
        ctx.lineWidth=2; 
        ctx.stroke(); 
      } 
      ctx.restore(); 
    }
  }

  function spawnEnemy(){
    const r = rand(10,18);
    const x = rand(r, W-r);
    const y = -r - rand(5,60);
    const speed = rand(40,140) + Math.max(0, Math.log(Math.max(1,score)) * 6);
    enemies.push(new Enemy(x,y,r,speed,'default'));
  }

  function loop(ts){
    if(!running) return;
    const dt = Math.min(0.04, (ts - lastTime) / 1000);
    lastTime = ts;
    elapsed += dt;
    const sec = Math.floor(elapsed);
    if(sec > lastSecAwarded){
      const gained = score * (sec - lastSecAwarded);
      if(gained > 0) addXP(gained);
      lastSecAwarded = sec;
    }

    lastSpawn += dt * 1000;
    const difficultyFactor = 1 + Math.floor(elapsed / 10) * 0.08;
    const currentSpawnInt = Math.max(220, spawnInterval / difficultyFactor);
    if(lastSpawn > currentSpawnInt){ spawnEnemy(); lastSpawn = 0; }

    enemies.forEach(e => e.update(dt));
    enemies = enemies.filter(e => e.alive);
    particles.forEach(p => p.update(dt));
    particles = particles.filter(p => p.age < p.life);

    if(lives <= 0){ endGame(); return; }
    if(Math.random() < 0.006){ score++; updateHUD(); }

    ctx.clearRect(0,0,W,H);
    ctx.globalAlpha = 0.06; 
    ctx.fillStyle = '#ffffff';
    for(let i=0;i<Math.ceil(H/30);i++){ 
      ctx.fillRect(0, i*30 + ((ts/30)%30), W, 1); 
    }
    ctx.globalAlpha = 1;
    
    enemies.forEach(e=>e.draw(ctx));
    particles.forEach(p=>p.draw(ctx));
    ctx.fillStyle = '#061323'; 
    ctx.fillRect(0, H-22, W, 22);
    ctx.fillStyle = '#083347'; 
    ctx.fillRect(0, H-22, W, 3);
    ctx.fillStyle = '#ffffff'; 
    ctx.globalAlpha = 0.06; 
    ctx.fillRect(8,8,110,34); 
    ctx.globalAlpha = 1;
    timeEl.textContent = Math.floor(elapsed);
    requestAnimationFrame(loop);
  }

  function resetGame(){ enemies=[]; particles=[]; lastSpawn=0; lastTime=performance.now(); elapsed=0; score=0; lives=10; running=false; gameOver=false; lastSecAwarded=Math.floor(elapsed); updateHUD(); if(startBtn) startBtn.disabled=false; if(restartBtn) restartBtn.disabled=true; setMsg('Ready. Click Start to begin!'); }
  
  function startGame(){ if(running) return; running=true; gameOver=false; lastTime=performance.now(); lastSecAwarded=Math.floor(elapsed); if(startBtn) startBtn.disabled=true; if(restartBtn) restartBtn.disabled=false; setMsg('Defend the base!'); requestAnimationFrame(loop); }
  
  function endGame(){ running=false; gameOver=true; if(startBtn) startBtn.disabled=false; if(restartBtn) restartBtn.disabled=true; setMsg('Game Over! Score: '+score); updateHUD(); }

  canvas.addEventListener('click',(e)=>{ if(!running||gameOver) return; const rect=canvas.getBoundingClientRect(); const mx=(e.clientX-rect.left)*(canvas.width/rect.width); const my=(e.clientY-rect.top)*(canvas.height/rect.height); for(let i=enemies.length-1;i>=0;i--){ const en=enemies[i]; const dx=en.x-mx, dy=en.y-my; if(Math.hypot(dx,dy)<=en.r+6){ en.alive=false; score += Math.round(10+en.r*1.5); updateHUD(); for(let p=0;p<12;p++) particles.push(new Particle(en.x+rand(-6,6), en.y+rand(-6,6), en.color)); addXP(10); break } } });

  if(startBtn) startBtn.addEventListener('click', ()=> startGame());
  if(restartBtn) restartBtn.addEventListener('click', ()=>{ resetGame(); startGame(); });

  loadProgress(); updateHUD(); resetGame();
})();
</script>
</body>
</html>
